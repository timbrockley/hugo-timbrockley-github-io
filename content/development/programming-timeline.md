---
layout: post
title: "Programming Timeline"
description: "Programming languages that I have used since the mid-1980s."
date: 2025-04-21
image: "/images/development/programming/programming_logo_200x200.png"
categories: ["development", "programming"]
tags: ["coding", "computer", "history", "language", "program", "programming", "timeline"]
---

## Programming languages that I have used over time

### BASIC

The first programming language I used was BASIC on a Toshiba MSX in the
mid-1980s. I used to write very simple arcade games to control graphics made up
of modified character blocks and small sprites. Most of my knowledge came from
reading personal computer magazines and from trial and error.

### Assembly Language

I learnt Assembly Language using a Commodore 64, but I spent more time playing
games than writing software.

### COBOL

At college, I learnt some COBOL on the Unix computer system there.

### RPG II

In my first programming job, I learnt to use RPG II on the company's IBM
System/36 mid-range system. When I started work there, all the company's
software was written using RPG II on green-screen dumb terminals. After gaining
more experience, I went on to fix bugs, update existing software and write new
RPG II code for the business.

### HTML, CSS and JavaScript

In the late 1990s, when the company installed a small network and some
IBM-compatible PCs, I used HTML, CSS and simple JavaScript to produce on-screen
reports which slowly replaced the paper-based reports generated by the existing
system.

### Perl and MySQL

The company replaced the IBM System/36 with an IBM AS/400 and a new suite of
software for the business. The new software didn't include any reporting tools,
so I wrote software using Perl to transfer data into a MySQL database. I adapted
the existing reports to display the new data and produce more detailed
management information and charts.

### Python

While working on the company system in the early 2000s, I rewrote some of the
software in Python to see if it offered any benefits, but ultimately it did not
offer any advantages over Perl given the system requirements.

Python proved better for data manipulation and number crunching, but up to now
all of the projects I've worked on were better suited to other languages.

I do like Python's coding style and would be open to using it again for suitable
projects.

### Java

I also started to learn Java with a view to developing applications to access
system data, but I decided it didn't offer enough benefits to warrant the steep
learning curve. I also didn't particularly enjoy writing code in Java, so I
chose not to continue with it.

### PHP

I kept hearing more and more about PHP, and on initial investigation it seemed
more suited to the intranet reports written in Perl. However, due to a company
policy at the time, PHP was not approved for use on the system.

Later, when I had more time at home, I learnt to code in PHP and actually
preferred it for online reporting and database access. I still prefer Perl for
some terminal-based data analysis, although other languages are arguably more
suitable for that purpose.

PHP is simple to set up and often included as standard by many web hosting
services. It allows developers to quickly create sophisticated web applications
without requiring any third-party libraries, although they are available for
more advanced or niche requirements.

It's not well suited for bulk operations or intensive number crunching.

### VBScript

I learnt VBScript when I started a new job at a bank and got an opportunity to
develop a search application that was hosted on a local intranet.

### Bash

I learnt Bash after switching to Linux as my main OS, as Windows had become
unusable on my laptop due to constant updates and the system randomly freezing
for 20 minutes or more at a time.

### Node.js

I learnt Node.js after hearing a lot of developers talk about it on YouTube. I
wrote a few CLI apps to help me bulk-edit code.

### Google Apps Script and Netlify

I created some JavaScript applications using Google Apps Script and Netlify
after learning about "Serverless" technology.

### TypeScript and Deno

Over the last few years, I've heard a lot of developers talk about TypeScript,
but I didn't want to add a compile step to the applications I was using at the
time.

However, I recently learnt about Deno and have used it to replace the
applications I originally wrote in Node.js. I now prefer using languages with
strict types, as this has helped me find numerous bugs and typos in older code.

Deno offers numerous built-in features that support back-end development. It's
easy to install and keep up to date.

### Go

I learnt about Go while applying for a new job. After doing some research, I
decided it would be a useful language to know. I spent just over a year learning
Go and found it enjoyable due to its simplicity, great support and quick
development times. It has strict types and blazingly fast compile times.

Go handles garbage collection, although it does offer some user control over
that process.

Go has some downsides though: its compiled binaries are quite large, and setting
up workspaces can be a bit clunky, which is sometimes an issue when starting a
new project.

Depending on the third-party libraries used, the downloaded library cache can be
several gigabytes in size, and there can sometimes be version conflicts that
aren't easy to resolve.

### Zig

While learning Go, I found that many developers also talked about using Zig for
systems programming. I started using Zig roughly a year ago after needing some
command-line applications with small binaries.

It has strict types and a few safety features to prevent common footguns found
in other languages like C. It's very fast—even compared to C or Rust.

Zig has excellent cross-compilation support for different OS targets and
includes a built-in C compiler. It has an extensive standard library and great
integration features. It's simple to set up and keep up to date.

Unfortunately, due to its ongoing development, many online code examples have
become outdated and cause compilation errors.

### Odin

Odin is a language I've heard about from other developers in the last few
months. In my experience, it offers many of the features provided by Go and Zig,
and I would consider it a good middle ground between them in terms of ease of
use and utility.

It has strict types and relatively simple manual garbage collection. It's easy
to set up and keep up to date.

Its compiled binaries are not as small as Zig's, but they're still relatively
compact, and it's also fast compared to other languages.

It's a relatively new language, so support isn't as widespread, but the provided
standard library is well developed and has a lot of built-in system
integrations.

## Other Languages I May Learn in the Future

### WebAssembly

Some people write directly in WebAssembly, but most use another language and
compile it into WebAssembly bytecode.

It's usually run in browsers where performance is important, but increasingly
it's being used to deploy applications across different platforms; removing the
need for separate versions for each system.

This is on my to-do list—more specifically, compiling to it from other code.

### Rust

Given enough time, I'd like to learn Rust and develop code with it. However,
based on what I've seen, I'm not sure it would offer enough benefits over Zig,
Odin or another language that already suits my needs.

Issues with slow compile times and the complexity of rewriting code have put me
off learning it for now.

### C and C++

C and C++ are languages I would like to learn eventually, but at the moment I
prefer Zig or Odin.

### Carbon

When version 1.0 of Carbon is eventually released with sufficient documentation,
it may be a great replacement for C or C++. Time will tell.

I'm personally open to learning it if and when the time is right.

### Other Languages

I'm always open to learning new things, although I currently want to concentrate
on the languages I'm already using.

If there's a compelling reason to learn a new language, I'll definitely consider
it.
